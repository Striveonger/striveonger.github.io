(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{535:function(t,a,s){"use strict";s.r(a);var r=s(4),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("设计模式之代理模式")]),t._v(" "),s("h3",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义:")]),t._v(" "),s("p",[t._v("代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。")]),t._v(" "),s("blockquote",[s("p",[t._v("在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。")])]),t._v(" "),s("h3",{attrs:{id:"开闭原则-增加功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则-增加功能"}},[t._v("#")]),t._v(" 开闭原则，增加功能：")]),t._v(" "),s("p",[t._v("代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。")]),t._v(" "),s("h3",{attrs:{id:"代理模式分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理模式分类"}},[t._v("#")]),t._v(" 代理模式分类")]),t._v(" "),s("h4",{attrs:{id:"静态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态代理"}},[t._v("#")]),t._v(" 静态代理")]),t._v(" "),s("h4",{attrs:{id:"动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[t._v("#")]),t._v(" 动态代理")])])}),[],!1,null,null,null);a.default=e.exports}}]);